#!/bin/sh /etc/rc.common
###
# Copyright (C) 2008 - 2010: Martin A. Campff, Sebasti√°n D. Criado, Gustavo Lindberg,
# Julio C. Puigpinos
# Contact list: lugro-mesh-dev@lugro-mesh.org.ar
# Version 0.7
#
# Originally based on R.O.B.I.N robin-c171 Copyright (C) 2007 Antonio Anselmi
# <a.anselmi-at-oltrelinux-dot-com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###

## /init.d/nightwing
START=96
start (){
## values
MESH_PREFIX=$(uci get network.mesh.ipaddr|awk -F "." '{print $1}')
PUBLIC_AP_NETMASK=$(uci get network.public.netmask)
PRIVATE_AP_NETMASK=$(uci get network.private.netmask)
PUBLIC_AP_IFACE=$(uci get network.public.ifname)
PRIVATE_AP_IFACE=$(uci get network.private.ifname)
MESH_IFACE=$(uci get network.mesh.ifname)
LAN_IFACE=$(uci get network.lan.ifname)
TUNNEL_IFACE=$(uci get network.bat.ifname)
TUNNEL_NETWORK="$(uci get network.bat.ipaddr)/$(uci get network.bat.netmask)"
IPCHECK=$(uci get nwnode.check.ip)
CLIENTWITHIP=0

## Parameters for B.A.T.M.A.N.-Experimental
## Choose the algorithm to found a gateway
ROUTING_CLASS=$(uci get bmxd.general.routing_class)
ORIGINATOR_INTERVAL=$(uci get bmxd.general.originator_interval)
VIS_SRV="$(uci get bmxd.general.visualisation_srv)"
BMX_ARGS=" -o $ORIGINATOR_INTERVAL"
GATEWAY_CLASS=$(uci get bmxd.general.gateway_class)
GATEWAY_IP=$(route -n | grep -A 4 UG | awk '{ print $2}')
MASK=$(ifconfig $LAN_IFACE | grep Mask | cut -d : -f 4)
LAN_MAC=$(ifconfig $LAN_IFACE | grep HWaddr | awk '{print $5}')
WIFI0_CHANNEL=$(uci get wireless.wifi0.channel)

## Adding the "Vis Server" if there
if [ ${VIS_SRV} ]; then
    BMX_ARGS="${BMX_ARGS} -s $VIS_SRV"
fi

## Paths
BMXD=/usr/sbin/bmxd
BMX_MODE_CONF=/etc/config/bmx_mode
RESOLV_CONF=/etc/resolv.conf
DNSMASQ_CONF=/tmp/dnsmasq.conf
DNSMASQ=/usr/sbin/dnsmasq
WIFIDOG_CONF=/tmp/wifidog.conf
IFCONFIG=/sbin/ifconfig
IWCONFIG=/usr/sbin/iwconfig
IPTABLES=/usr/sbin/iptables
ROUTE=/sbin/route

hex2dec () {
        local i=$1
        let x=0x$(echo $LAN_MAC | cut $i)
        echo $x
}

## Define Net base for VAP's
IP_BASE="$(uci get network.public.ipaddr| \
awk -F "." '{print $1}').$(hex2dec -c13-14).$(hex2dec -c16-17)"

## PUBLIC_AP IP
IP_PUBLIC_AP="${IP_BASE}.1"

if  [ -f /etc/rc.d/S60dnsmasq ]; then
    /etc/init.d/dnsmasq stop
    /etc/init.d/dnsmasq disable
fi

## Check if bmxd daemon is running, if so stop and disable it.
if  [ -f /etc/rc.d/S91bmxd ]; then
    killall bmxd
    /etc/init.d/bmxd disable
fi

## Check if WiFiDog daemon is running, if so stop and disable it and change some configs.
if  [ -f /etc/rc.d/S65wifidog ]; then
    /etc/init.d/wifidog stop
    /etc/init.d/wifidog disable

    ## Determine nodo_id for the first time. Then it could be changed.
    let NODE_ID=0x$(echo $LAN_MAC| awk -F: '{print $5$6}')
    PUBLIC_SSID=$(uci get nwnode.public.ssid)
    PRIVATE_SSID=$(uci get nwnode.private.ssid)
    uci set wireless.public.ssid=${PUBLIC_SSID}-${NODE_ID}
    uci set wireless.private.ssid=${PRIVATE_SSID}-${NODE_ID}
    $IWCONFIG $PUBLIC_AP_IFACE essid ${PUBLIC_SSID}-${NODE_ID}
    $IWCONFIG $PRIVATE_AP_IFACE essid ${PRIVATE_SSID}-${NODE_ID}
    uci set wifidog.node.id=$NODE_ID
    uci commit wifidog
    uci commit wireless

    ## Set config for WiFiDog
    sed -i '
	{
	/GatewayID/s/GatewayID default/GatewayID '$NODE_ID'/;
	s/GatewayAddress/GatewayAddress '$IP_PUBLIC_AP'/;
	}' /etc/wifidog.conf
    mv /etc/wifidog.conf /etc/wifidog.conf.sample
    ln -s $WIFIDOG_CONF /etc/wifidog.conf
fi

## Check if WiFiDog config has changed
if [ "$(uci get wifidog.node.change)" == 1  ]; then
    sed -i '
    {
	/HTTPDUserName/s/HTTPDUserName .*/HTTPDUserName '$(uci get wifidog.node.HTTPDUserName)'/;
	/HTTPDPassword/s/HTTPDPassword .*/HTTPDPassword '$(uci get wifidog.node.HTTPDPassword)'/;
        /Hostname/s/Hostname .*/Hostname '$(uci get wifidog.node.server)'/;
        /SSLAvailable/s/SSLAvailable .*/SSLAvailable '$(uci get wifidog.node.ssl)'/;
    }
	' /etc/wifidog.conf.sample
	uci set wifidog.node.change=0
	uci commit wifidog
fi

## Write wifidog.conf in /tmp
cp /etc/wifidog.conf.sample $WIFIDOG_CONF


## Discover its own role.
## If we have Internet access, then the node is a gateway. Otherwise is a client.
if [ $(fping -a $IPCHECK 2>/dev/null|wc -l) == 0 ];
	then
		{
		if [ $GATEWAY_IP ]; then
		    if [ $(echo $GATEWAY_IP|cut -c1-7) == "169.254" ]; then
			logger -s -t  "nightwing" "Mode client, Zero Configuration Networking detected"
			MODE="client"
		    else
		    logger -s -t  "nightwing" "Mode client, with LAN ip from external DHCP Server"
			MODE="client"
			CLIENTWITHIP=1
		    fi
		else
		    MODE="client"
		fi
		}
	else
		MODE="gateway"
fi

## Calculate the IP for all ifaces
##

## PRIVATE_AP IP
IP_PRIVATE_AP="${IP_BASE}.129"

## LAN IP
IP_LAN="${IP_BASE}.193"

## Calculate IP mesh iface based on MAC address in the subnet 5.x.x.x
IP_MESH="${MESH_PREFIX}.$(hex2dec -c10-11).$(hex2dec -c13-14).$(hex2dec -c16-17)"

#Up PUBLIC iface
$IFCONFIG "$PUBLIC_AP_IFACE" "$IP_PUBLIC_AP" netmask "$PUBLIC_AP_NETMASK"

## Up PRIVATE iface
$IFCONFIG "$PRIVATE_AP_IFACE" "$IP_PRIVATE_AP" netmask "$PRIVATE_AP_NETMASK"

## Up MESH  iface
$IFCONFIG "$MESH_IFACE" "$IP_MESH"

## Workaround to buggy MADWiFi HAL. Reconfigure to selected channel
$IWCONFIG "$MESH_IFACE" "channel" "$WIFI0_CHANNEL"

## Calculate range and lease for PUBLIC_AP dhcp server.
PUBLIC_AP_S_LEASE="${IP_BASE}.2" ; PUBLIC_AP_E_LEASE="${IP_BASE}.126"
RANGE_PUBLIC="${PUBLIC_AP_S_LEASE},${PUBLIC_AP_E_LEASE},${PUBLIC_AP_NETMASK},12h"

## Calculate range and lease for PRIVATE_AP dhcp server.
PRIVATE_AP_S_LEASE="${IP_BASE}.130" ; PRIVATE_AP_E_LEASE="${IP_BASE}.190"
RANGE_PRIVATE="${PRIVATE_AP_S_LEASE},${PRIVATE_AP_E_LEASE},${PRIVATE_AP_NETMASK},12h"

### Write bmx mode
echo "config bmx_mode node"	> 	$BMX_MODE_CONF
echo "     option mode"		>> 	$BMX_MODE_CONF
echo "     option clientwithip"	>> 	$BMX_MODE_CONF
uci set bmx_mode.node.mode=$MODE
uci set bmx_mode.node.clientwithip=$CLIENTWITHIP
uci commit bmx_mode

## Write DNSMASQ conf for every VAP (PUBLIC & PRIVATE)
cat > $DNSMASQ_CONF << EOF
domain-needed
bogus-priv
filterwin2k
bind-interfaces
resolv-file=/etc/resolv.conf.default
dhcp-leasefile=/tmp/dhcp.leases
dhcp-authoritative
dhcp-range=public,$RANGE_PUBLIC
dhcp-option=public,3,$IP_PUBLIC_AP
interface=$PUBLIC_AP_IFACE
dhcp-range=private,$RANGE_PRIVATE
dhcp-option=private,3,$IP_PRIVATE_AP
interface=$PRIVATE_AP_IFACE
EOF

# Extract nameservers
PRIVATE_AP_DNS=$(for i in $( cat $RESOLV_CONF | grep ^nameserver | cut -d " " -f2); do echo -n $i","; done | sed 's/,$//')

case $MODE in
	gateway)
		logger -s -t  "nightwing" "The node is a Gateway"

		logger -s -t  "nightwing" "Start WiFiDog captive portal ... "
		/etc/init.d/wifidog start

		# Wait 10 seconds for iptables rules
		sleep 10
		logger -s -t  "nightwing" "WiFiDog captive portal started "

		### Write IP of LAN_IFACE
		IP_LAN="$($IFCONFIG $LAN_IFACE| awk 'NR==2 {print $2}'| awk -F: '{print $2}')"
		echo "$IP_LAN" > /tmp/current-${LAN_IFACE}-ip

		## Start bmxd - B.A.T.M.A.N.-Experimental
		logger -s -t  "nightwing" "Starting bmxd ... "
		BMX_ARGS="${BMX_ARGS} -g $GATEWAY_CLASS"
		BMX_ARGS="${BMX_ARGS} --dev $MESH_IFACE"

		echo $BMX_ARGS > /var/run/bmxd.arg

		$BMXD $BMX_ARGS
		logger -s -t  "nightwing" "bmxd started"

		## Adjust DNS value for PRIVATE_AP dhcp leases ( LAN dns servers ) and listen in TUNNEL_IFACE
		echo "dhcp-option=private,6,$PRIVATE_AP_DNS" >> $DNSMASQ_CONF
		echo "interface="$TUNNEL_IFACE               >> $DNSMASQ_CONF

		## DNSMAQ up for every VAP
		$DNSMASQ -C $DNSMASQ_CONF
		logger -s -t  "nightwing" "DNSMasq started"

		logger -s -t  "nightwing" "Starting to apply iptables rules ..."
		## SNAT
		$IPTABLES -t nat -I POSTROUTING -o $LAN_IFACE -j SNAT --to-source $IP_LAN

		#We detect public IP Internet automatically
		#INET_PUBLIC_IP=$(wget -q -O- http://www.whatismyip.com/automation/n09230945.asp)
		INET_PUBLIC_IP=$(wget -q -O- http://lugro-mesh.org.ar/whatismyip.php)
		echo "$INET_PUBLIC_IP" > /tmp/current-wan-ip

		## Close ssh and www ports except local LAN and PRIVATE iface
		$IPTABLES -I INPUT -p tcp --dport 22 -j DROP
		$IPTABLES -I INPUT -p tcp --dport 80 -j DROP
		$IPTABLES -I INPUT -i $PRIVATE_AP_IFACE -p tcp --dport 22 -j ACCEPT
		$IPTABLES -I INPUT -i $PRIVATE_AP_IFACE -p tcp --dport 80 -j ACCEPT
		$IPTABLES -I INPUT -i $LAN_IFACE -p tcp --dport 22 -j ACCEPT
		$IPTABLES -I INPUT -i $LAN_IFACE -p tcp --dport 80 -j ACCEPT

		# By default we close any incoming traffic from PUBLIC_AP_IFACE or MESH to the IP address of the Internet.
		# This will block access from the public or mesh interface to resources availables only to the LAN
		# at the point of connection to the Internet.
		# If necessary enable a port for access from the public interface or mesh network, you only need to add
		# a line with -j ACCEPT.
		# Ej:
		# For PUBLIC_AP_IFACE:
		# $IPTABLES -I FORWARD -i $PUBLIC_AP_IFACE -p tcp --dport 80 -d $INET_PUBLIC_IP -j ACCEPT
		# For MESH NEtwork:
		# $IPTABLES -I FORWARD -s $TUNNEL_NETWORK -p tcp --dport 80 -d $INET_PUBLIC_IP -j ACCEPT
		$IPTABLES -I FORWARD -i $PUBLIC_AP_IFACE -d $INET_PUBLIC_IP -j DROP
		$IPTABLES -I FORWARD -s $TUNNEL_NETWORK -d $INET_PUBLIC_IP -j DROP

		## Drop external packets towards LAN
		$IPTABLES -I FORWARD -d ${GATEWAY_IP}/${MASK} -j DROP
		$IPTABLES -I FORWARD -i $PUBLIC_AP_IFACE -o $PRIVATE_AP_IFACE -j DROP
		### Drop external packet towards LAN (IANA reserved RFC1918)
		$IPTABLES -I FORWARD -i $PUBLIC_AP_IFACE -d 10.0.0.0/8 -j DROP
		$IPTABLES -I FORWARD -i $PUBLIC_AP_IFACE -d 172.16.0.0/12 -j DROP
		$IPTABLES -I FORWARD -i $PUBLIC_AP_IFACE -d 192.168.0.0/16 -j DROP

		$IPTABLES -I FORWARD -i $PRIVATE_AP_IFACE -o $PUBLIC_AP_IFACE -j DROP
		$IPTABLES -I FORWARD -i $PRIVATE_AP_IFACE -d ${GATEWAY_IP}/${MASK} -j ACCEPT
		$IPTABLES -I OUTPUT -s $TUNNEL_NETWORK -o $LAN_IFACE -d  ${GATEWAY_IP}/${MASK} -j DROP

		### Drop external packet towards PRIVATE_AP_IFACE
		$IPTABLES -I FORWARD -i $TUNNEL_IFACE -o $PRIVATE_AP_IFACE -j DROP

		# Intercept DNS Query in PUBLIC_AP_IFACE/MESH and REDIRECT to local dns
		$IPTABLES -t nat -I PREROUTING -i $PUBLIC_AP_IFACE -p udp --dport 53 -j REDIRECT --to-port 53
		$IPTABLES -t nat -I PREROUTING -i $PUBLIC_AP_IFACE -p tcp --dport 53 -j REDIRECT --to-port 53
		$IPTABLES -t nat -I PREROUTING -s $TUNNEL_NETWORK -p udp --dport 53 -j REDIRECT --to-port 53
		$IPTABLES -t nat -I PREROUTING -s $TUNNEL_NETWORK -p tcp --dport 53 -j REDIRECT --to-port 53
		logger -s -t  "nightwing" "Finishing applying iptables rules ..."
		
		TS_STATUS=$(uci get nwnode.ts.status)
		if [ "$TS_STATUS" != 0 ]; then
		   /usr/bin/nw_ts_${TS_STATUS} start
		fi
		;;
	client)
		logger -s -t  "nightwing" "The node is a Client"
		
		logger -s -t  "nightwing" "Start WiFiDog captive portal ..."

		# Using dnsmasq for local nameserver
		echo -n > $RESOLV_CONF
		echo "nameserver 127.0.0.1" > $RESOLV_CONF

		# WiFiDog uses Mesh interface
		sed -i "s/ExternalInterface .*/ExternalInterface "$TUNNEL_IFACE"/" $WIFIDOG_CONF

		# Start WiFiDog captive portal
		/etc/init.d/wifidog start
		logger -s -t  "nightwing" "WiFiDog captive portal started"

		# Wait 10 seconds for iptables rules
		sleep 10

		if [ $CLIENTWITHIP == "0" ]; then
		## Up eth0 in the corresponding subnet
		    LAN_MASK=$(uci get network.lan.netmask)
		    $IFCONFIG $LAN_IFACE $IP_LAN netmask $LAN_MASK
		## Set range and lease for dhcp server
		    LAN_S_LEASE="${IP_BASE}.194"
		    LAN_E_LEASE="${IP_BASE}.254"
		    RANGE_LAN="${LAN_S_LEASE},${LAN_E_LEASE},${LAN_MASK},12h"
		## Adjust DNS value for LAN_IFACE dhcp leases
		    echo "dhcp-range=lan,"$RANGE_LAN	>> $DNSMASQ_CONF
		    echo "dhcp-option=lan,3,"$IP_LAN	>> $DNSMASQ_CONF
		    echo "interface="$LAN_IFACE         >> $DNSMASQ_CONF
		fi

		### Write IP of LAN_IFACE
		echo "$IP_LAN"  > /tmp/current-${LAN_IFACE}-ip

		logger -s -t  "nightwing" "Starting to apply iptables rules ..."
		## Close ssh and www ports except local LAN and PRIVATE iface
		$IPTABLES -I INPUT -p tcp --dport 22 -j DROP
		$IPTABLES -I INPUT -p tcp --dport 80 -j DROP
		$IPTABLES -I INPUT -i $PRIVATE_AP_IFACE -p tcp --dport 22 -j ACCEPT
		$IPTABLES -I INPUT -i $PRIVATE_AP_IFACE -p tcp --dport 80 -j ACCEPT
		$IPTABLES -I INPUT -i $LAN_IFACE -p tcp --dport 22 -j ACCEPT
		$IPTABLES -I INPUT -i $LAN_IFACE -p tcp --dport 80 -j ACCEPT

		## Drop all coming from PUBLIC_IFACE to PRIVATE_IFACE and to LAN and from PUBLIC_IFACE of other node
		$IPTABLES -I FORWARD -i $PUBLIC_AP_IFACE -o $PRIVATE_AP_IFACE -j DROP
		$IPTABLES -I FORWARD -i $PRIVATE_AP_IFACE -o $PUBLIC_AP_IFACE -j DROP
		$IPTABLES -I OUTPUT -s $TUNNEL_NETWORK -o $LAN_IFACE -d ${IP_LAN}/${LAN_MASK} -j DROP
		$IPTABLES -I OUTPUT -s $TUNNEL_NETWORK -o $PUBLIC_AP_IFACE -d ${IP_PUBLIC_AP}/8 -j DROP
		logger -s -t  "nightwing" "Finishing applying iptables rules ..."

		## Start DNSMAQ on every iface
		$DNSMASQ -C $DNSMASQ_CONF
		logger -s -t  "nightwing" "DNSMasq started"

		## Start bmxd - B.A.T.M.A.N.-Experimental
		BMX_ARGS="${BMX_ARGS} -r $ROUTING_CLASS"
		BMX_ARGS="${BMX_ARGS} --dev $MESH_IFACE"

		echo $BMX_ARGS > /var/run/bmxd.arg

		$BMXD $BMX_ARGS
		logger -s -t  "nightwing" "bmxd started"

		## Waiting to find a gateway
		logger -s -t  "nightwing" "Waiting to find a Gateway node"
		while true ; do
			bgw=$(bmxd -c -d 2 | grep = | awk '{print $2}')
				! [ -z $bgw ] && break
				sleep 15
			done
		
		logger -s -t  "nightwing" "Gateway node found"

		## Masquerade tun iface
		$IPTABLES -t nat -I POSTROUTING -o $TUNNEL_IFACE -j MASQUERADE

		# Clamp MTU value
		$IPTABLES -A FORWARD -p tcp --tcp-flags SYN,RST SYN -m tcpmss --mss 1400:1536 -j TCPMSS --clamp-mss-to-pmtu
		logger -s -t  "nightwing" "Masqueraded tunnel interface"
		;;
esac

}
stop () {
	logger -s -t  "nightwing" "Stopping bmx ... "

	killall bmxd
	killall dnsmasq
	sleep 3; T=0; Tmax=15
	while [ -n "$(pidof bmxd)" ]; do
	   echo -n "."; sleep 1; T=$(( $T + 1 ))
	   if [ $T -ge $Tmax ];then
	      echo
	      killall -SIGKILL bmxd
	      break
	   fi
	done
	/etc/init.d/wifidog stop
	TS_STATUS=$(uci get nwnode.ts.status)
	if [ "$TS_STATUS" != 0 ]; then
		/usr/bin/nw_ts_${TS_STATUS} stop
	fi
	logger -s -t  "nightwing" "stopped"
}
## Have fun!
